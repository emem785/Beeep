// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'receive_beep_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$ReceiveBeepStateTearOff {
  const _$ReceiveBeepStateTearOff();

  ReceiveBeepInitial initial() {
    return const ReceiveBeepInitial();
  }

  ReceiveBeepLawyersGotten lawyersGotten() {
    return const ReceiveBeepLawyersGotten();
  }
}

// ignore: unused_element
const $ReceiveBeepState = _$ReceiveBeepStateTearOff();

mixin _$ReceiveBeepState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result lawyersGotten(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result lawyersGotten(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(ReceiveBeepInitial value),
    @required Result lawyersGotten(ReceiveBeepLawyersGotten value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(ReceiveBeepInitial value),
    Result lawyersGotten(ReceiveBeepLawyersGotten value),
    @required Result orElse(),
  });
}

abstract class $ReceiveBeepStateCopyWith<$Res> {
  factory $ReceiveBeepStateCopyWith(
          ReceiveBeepState value, $Res Function(ReceiveBeepState) then) =
      _$ReceiveBeepStateCopyWithImpl<$Res>;
}

class _$ReceiveBeepStateCopyWithImpl<$Res>
    implements $ReceiveBeepStateCopyWith<$Res> {
  _$ReceiveBeepStateCopyWithImpl(this._value, this._then);

  final ReceiveBeepState _value;
  // ignore: unused_field
  final $Res Function(ReceiveBeepState) _then;
}

abstract class $ReceiveBeepInitialCopyWith<$Res> {
  factory $ReceiveBeepInitialCopyWith(
          ReceiveBeepInitial value, $Res Function(ReceiveBeepInitial) then) =
      _$ReceiveBeepInitialCopyWithImpl<$Res>;
}

class _$ReceiveBeepInitialCopyWithImpl<$Res>
    extends _$ReceiveBeepStateCopyWithImpl<$Res>
    implements $ReceiveBeepInitialCopyWith<$Res> {
  _$ReceiveBeepInitialCopyWithImpl(
      ReceiveBeepInitial _value, $Res Function(ReceiveBeepInitial) _then)
      : super(_value, (v) => _then(v as ReceiveBeepInitial));

  @override
  ReceiveBeepInitial get _value => super._value as ReceiveBeepInitial;
}

class _$ReceiveBeepInitial implements ReceiveBeepInitial {
  const _$ReceiveBeepInitial();

  @override
  String toString() {
    return 'ReceiveBeepState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ReceiveBeepInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result lawyersGotten(),
  }) {
    assert(initial != null);
    assert(lawyersGotten != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result lawyersGotten(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(ReceiveBeepInitial value),
    @required Result lawyersGotten(ReceiveBeepLawyersGotten value),
  }) {
    assert(initial != null);
    assert(lawyersGotten != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(ReceiveBeepInitial value),
    Result lawyersGotten(ReceiveBeepLawyersGotten value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ReceiveBeepInitial implements ReceiveBeepState {
  const factory ReceiveBeepInitial() = _$ReceiveBeepInitial;
}

abstract class $ReceiveBeepLawyersGottenCopyWith<$Res> {
  factory $ReceiveBeepLawyersGottenCopyWith(ReceiveBeepLawyersGotten value,
          $Res Function(ReceiveBeepLawyersGotten) then) =
      _$ReceiveBeepLawyersGottenCopyWithImpl<$Res>;
}

class _$ReceiveBeepLawyersGottenCopyWithImpl<$Res>
    extends _$ReceiveBeepStateCopyWithImpl<$Res>
    implements $ReceiveBeepLawyersGottenCopyWith<$Res> {
  _$ReceiveBeepLawyersGottenCopyWithImpl(ReceiveBeepLawyersGotten _value,
      $Res Function(ReceiveBeepLawyersGotten) _then)
      : super(_value, (v) => _then(v as ReceiveBeepLawyersGotten));

  @override
  ReceiveBeepLawyersGotten get _value =>
      super._value as ReceiveBeepLawyersGotten;
}

class _$ReceiveBeepLawyersGotten implements ReceiveBeepLawyersGotten {
  const _$ReceiveBeepLawyersGotten();

  @override
  String toString() {
    return 'ReceiveBeepState.lawyersGotten()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ReceiveBeepLawyersGotten);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result lawyersGotten(),
  }) {
    assert(initial != null);
    assert(lawyersGotten != null);
    return lawyersGotten();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result lawyersGotten(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (lawyersGotten != null) {
      return lawyersGotten();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(ReceiveBeepInitial value),
    @required Result lawyersGotten(ReceiveBeepLawyersGotten value),
  }) {
    assert(initial != null);
    assert(lawyersGotten != null);
    return lawyersGotten(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(ReceiveBeepInitial value),
    Result lawyersGotten(ReceiveBeepLawyersGotten value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (lawyersGotten != null) {
      return lawyersGotten(this);
    }
    return orElse();
  }
}

abstract class ReceiveBeepLawyersGotten implements ReceiveBeepState {
  const factory ReceiveBeepLawyersGotten() = _$ReceiveBeepLawyersGotten;
}
